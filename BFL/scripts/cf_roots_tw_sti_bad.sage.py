

# This file was *autogenerated* from the file /home/alesavou/Documents/Projects/roots-crt/online-pre/scripts/cf_roots_twphs_saturation_bad.sage
from sage.all_cmdline import *   # import sage library

_sage_const_123457 = Integer(123457); _sage_const_10 = Integer(10); _sage_const_1 = Integer(1); _sage_const_60 = Integer(60); _sage_const_2 = Integer(2); _sage_const_3 = Integer(3); _sage_const_7 = Integer(7); _sage_const_400 = Integer(400); _sage_const_4 = Integer(4); _sage_const_200 = Integer(200); _sage_const_0 = Integer(0); _sage_const_5000 = Integer(5000); _sage_const_300 = Integer(300); _sage_const_1000 = Integer(1000)# Code in support of ISSAC'23 Submission #7564
# Copyright 2023, <anonymous-roots-crt>
# GPL-3.0-only (see LICENSE file)

#!/usr/bin/env sage
from sage import *
load("../src/cf_roots.sage")

sys.path.append("../Tw-Sti/src/");

import sys
from pcmp_io import *
from nf import *
from cyclotomics import *
from circular import *
from stim_q import *
from saturation import *

proof.number_field(False);
proof.arithmetic(False);

# necessary for finite fields embeddings
from sage.rings.finite_rings.hom_finite_field import FiniteFieldHomomorphism_generic

set_random_seed(_sage_const_123457 )

# ------------------------------------------------------------------------------
# Pari stack size for computing Cl_K+
pari.allocatemem(_sage_const_10 **_sage_const_10 ); # Avoid "out of memory" when using Pari on the laptop

# ------------------------------------------------------------------------------
# which prime e to pick : min or max factor of gcd(m, h_m^-)
if len(sys.argv) == _sage_const_1 :
    type_prime="min"            # which e | gcd(m, h_m^-) : min or max
    size_primes=_sage_const_60               # size of primes taken in couv. method
elif len(sys.argv) == _sage_const_2 :
    type_prime=sys.argv[_sage_const_1 ]
    size_primes=_sage_const_60 
elif len(sys.argv) == _sage_const_3 :
    type_prime=sys.argv[_sage_const_1 ]
    size_primes=ZZ(sys.argv[_sage_const_2 ])


str_file = '../data/cf_twphs_stickel_saturation_bad_' + type_prime + '_' + str(size_primes)
# data file

d = _sage_const_2 ; # d = number of orbits 

for m in range(_sage_const_7 , _sage_const_400 ):

    if mod(m, _sage_const_4 )==_sage_const_2  or euler_phi(m) > _sage_const_200  or cf_hplus(m)>_sage_const_1 :
        continue

    print("_______________     Conductor is ", m, "     _______________")
    n  = euler_phi(m);
    K  = CyclotomicField(m);
    #hK = K.class_number();
    hm = cf_hminus(m); hK = hm;
    g = gcd(m,hK);
    if (g == _sage_const_1 ):
        continue
    else:
        fg = g.factor()
        if type_prime=='min':
            ep = ZZ(fg[_sage_const_0 ][_sage_const_0 ])
        elif type_prime=='max':
            ep = ZZ(fg[-_sage_const_1 ][_sage_const_0 ])
        else:
            raise ValueError('type_prime should be min or max')
    if ep == _sage_const_2 :
        continue

    print("Non trivial factor / exponent found: ", ep)

    f = open(str_file, 'a')
    f.write(str(m) + "\t" + str(n) + "\t" + str(ep) + "\t")
    f.close()


    # computation of orbits for saturation
    Lp = cf_d_first_split_primes(K,d=d);
    L  = cf_d_orbits(K,d=d); L1 = L[:n]; L2 = L[n:]; 
    id_p = [ L[_d*n] for _d in range(d) ]; assert(len(id_p) == d);

    # -------------------------------------------------------------------------
    # then computation of the plain subgroup of S-units named URS as in ASIACRYPT'22 paper [Ber+22]
    # Read them from file instead ?
    urs_f = "../Tw-Sti/data/z{}/z{}_d{}.urs".format(m,m,d);
    if (os.path.exists(urs_f)):
        print("Reading S-units 'urs' from '{}'".format(urs_f));
        (yu_all, ysu_all), B_all, Vp_all = sunits_raw_read_data(urs_f, K);
        Uw = cf_cyclotomic_units(K);
        Rw = sum( (B_all[len(Uw)+_d*n:      len(Uw)+_d*n+n//_sage_const_2 ] for _d in range(d)), []);
        Sw = sum( (B_all[len(Uw)+_d*n+n//_sage_const_2 : len(Uw)+(_d+_sage_const_1 )*n]  for _d in range(d)), []);
        urs_valp = matrix(ZZ, sum( ( Vp_all[len(Uw)+_d*n: len(Uw)+_d*n+n//_sage_const_2 ] for _d in range(d)), [])
                          + sum( ( Vp_all[len(Uw)+_d*n+n//_sage_const_2 : len(Uw)+(_d+_sage_const_1 )*n] for _d in range(d)), []));
    else:
        Uw = cf_cyclotomic_units(K);
        Rw = sum( (real_gens(K,_p) for _p in Lp), []);
        Sw = sum( (sti_gens_alpha(K,_id_p)[_sage_const_1 :] for _id_p in id_p), []);
        urs_valp = Matrix(ZZ,[[ _s.valuation(_id_p) for _id_p in L] for _s in Rw+Sw]);

    urs = Uw + Rw + Sw;
    print("S-units 'urs' ok", flush=True);
    assert(len(urs) == d*n + n//_sage_const_2  - _sage_const_1 );
    print("Valuations computed", flush=True);
    assert(urs_valp.is_square());
    assert(urs_valp.determinant().abs() ==
           _sage_const_2 **(d*(n//_sage_const_2 -_sage_const_1 +(_sage_const_0  if ZZ(m).is_prime_power() else _sage_const_2 **(len(ZZ(m).factor())-_sage_const_2 )-_sage_const_1 ))) * hm**(d-_sage_const_1 ) * hK);
    # ------------------------------------------------------------------------
    
    # Find a e-th root (bad case).
    er = ep

    # sauf erreur on n'a pas besoin de la torsion ssi gcd(e,n) = 1
    ##### Quand inclure la torsion ?? For (m,e)=(37,37) not needed, for (m,e)=(76,19) needed, idem for (69,23)
    ##### For (m,e) = (96,9): not needed.
    if (gcd(er,m)>_sage_const_1  and gcd(er,m)<m):
        print("gcd(er,m) = {} --> adding torsion units".format(gcd(er,m)));
        urs = [-K.gen()] + urs;

    print("Computing e-th root for e={}".format(er));
    # -------------------------------------------------------------------------
    # computation of characters and kernel to detect non trivial power
    
    print("Characters = 1[{}]".format(lcm(m,er)), flush=True);

    chi_e = sat_get_suitable_chip(urs, d=lcm(m,er), smooth_V=Lp[-_sage_const_1 ], __per_orbit=_sage_const_1 , __overhead=_sage_const_10 ); # Returns list of pid
    # nb: overkill, we should reuse the matrix of valuations as free additional characters (as was done for e=2)

    t=cputime(); chi_B = matrix(IntegerModRing(er), [[log_chip_dth_power(_chi,_su,d=er) for _chi in chi_e] for _su in urs ]); t=cputime(t);
    print("Calcul characters: {:.2f}s".format(t));
    # En fait, il semble que la partie U+R n'est pas impliquée. En un sens c'est logique mais ça pose d'autres questions.
    if (er.is_prime()):
        H     = matrix(ZZ, matrix(GF(er),chi_B.left_kernel().basis_matrix())); # map in -e/2,e/2 ? quotients relous
    else:
        assert(er.is_prime_power());
        ###### Pb for detecting e^k !! No echelon_form algorithm mod non prime integers
        ###### See https://ask.sagemath.org/question/44815/finding-the-kernel-of-a-matrix-in-a-non-integral-domain/
        ###### --> For ZZ/e^kZZ:
        ######     - Write each coeff as polynomial in GF(e)[t]/<t^k> 
        ######     - Write an unknown vector of kernel as poly in GF(e)[t]/<t^k> (so k*dim indeterminates)
        ######     - Write the v.M product to obtain dim equations (poly deg k = 0)
        ######     - "Weil descent" to obtain a linear system over GF(e).
        print("Ooops! TODO: find kernel of matrix over {}".format(er));
        # Suggestion
        # Zerk = IntegerModRing(ep**k);
        # Fe = GF(ep);
        #    mult_tk = [ block_matrix(Fe, [[column_matrix(_k, k-_k), identity_matrix(k-_k)], [zero_matrix(_k,k)]], subdivide=False)
        #                for _k in range(k) ]; # Multiplication matrices by t^_k in GF(e)[t]/<t^k>
        
        # Try https://ask.sagemath.org/question/33890/how-to-find-kernel-of-a-matrix-in-mathbbzn/
        # Zi   = ZZ^(chi_B.nrows()); Zie = Zi/(er*Zi);
        # Zo   = ZZ^(chi_B.ncols()); Zoe = Zo/(er*Zo);
        # t = cputime(); Zermap = Zie.hom([ Zoe(_v) for _v in chi_B]); t = cputime(t);
        # print("construct Map on Z/{}Z: {:.2f}".format(er,t));
        # t=cputime(); H    = matrix(ZZ, [vector(ZZ, Zie(_v)) for _v in Zermap.kernel().gens()]); t = cputime(t);
        # print("Find kernel on Z/{}Z: {:.2f}".format(er,t));
        
        # Use Howell normal form (thx JP FLori) and matkermod() fct in Pari
        H     = matrix(ZZ, pari(matrix(ZZ,chi_B).transpose()).matkermod(er)).transpose(); # map in -e/2,e/2 ? quotients relous
        # print(H);
    
    print("Rang noyau: {}".format(H.rank()));

    # ----------------------------------------------------------------------

    phi = get_inf_places(K,_sage_const_5000 );
    lurs = [ logarg_set(_u, phi) for _u in urs ];
    se   = [ logarg_mpow(lurs, _H) for _H in H.rows() ];

    print("[]-norm se: {:.2f}".format(logarg_lnSnorm_cf(se[_sage_const_0 ])));
    s    = [ logarg_pow(_s, _sage_const_1 /er) for _s in se ];
    print("[]-norm s:  {:.2f}".format(logarg_lnSnorm_cf(s[_sage_const_0 ])));

    # Quick-and-dirty thing that fits well with real measurements above
    Be = max([ sum(H[i][j]* log(vector(ComplexField(_sage_const_300 ), urs[j].complex_embeddings(prec=_sage_const_300 )).norm(infinity),_sage_const_2 )
                   for j in range(len(urs))) for i in range(H.nrows())]);
    print("log h(s^e) = {:.2f}".format(Be));

    B  = Be / er;
    print("log h(s) = {:.2f}".format(B));
    B = _sage_const_2 **B;


    red_fct = lll_ZZ;
    
    # ----------------------- Tests methods : our rec method -------------------
    s_root=[];
    t_root = _sage_const_0 ;
    t_norm = _sage_const_0 ;
    for i in range(H.nrows()):
        print("Sol {}".format(i));

        t = cputime(); res, _t_norm = cf_roots_rec(urs, H[i], ZZ(er), K, m, size_primes); t = cputime(t); 
        t_root += t;
        t_norm += _t_norm;        
        print("\tTime Root: {:.4f}s".format(t));
        s_root.append(res);
        # Check
        ls_root = logarg_set(s_root[-_sage_const_1 ], phi);
        print("\tOur method: Check log, arg mod 2pi/e: \x1b[{}OK\x1b[0m"
              .format("32m" if logarg_is_equal(ls_root,s[i],argmod=er) else "31mN"));

        # The assert are here to quantify how far are the values for diagnostic
        assert(fp.fp_assert_equal("", ls_root.inf, s[i].inf, target=_sage_const_1000 ));
        assert(fp.fp_assert_zero("", [min(_th.abs(), _sage_const_1 -_th.abs()) for _th in logarg_reduce_args(er*ls_root.args) - logarg_reduce_args(er*s[i].args)], target=_sage_const_1000 ));
    
    t_root = "%.2f" % t_root
    t_norm = "%.2f" % t_norm
    f = open(str_file, 'a')
    f.write(str(H.nrows()) + "\t" + t_norm + "\t" + t_root + "\n")
    f.close()

    

